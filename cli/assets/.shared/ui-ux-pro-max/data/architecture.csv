term,description,structure,benefits,trade_offs,implementation_guide,examples,testing_approach,category,complexity
feature-slice,Vertical organization of code by business features rather than technical layers,/src/features/user-management/{components types hooks services api},Improved maintainability easier feature additions better team collaboration,Potential code duplication across features initial setup complexity,Create feature directories with index.js exports use absolute imports maintain shared utilities in common folder,Auth feature: {LoginForm UserProfile AuthAPI UserHooks} in single directory,Test entire feature slice as unit with integration tests for feature boundaries,Feature-Based,Medium
hexagonal-architecture,Ports and adapters pattern isolating business logic from external concerns,Core domain surrounded by adapter layer with port interfaces,Technology independence easy testing highly maintainable business logic,Learning curve initial abstraction overhead,Define port interfaces implement adapters for each external system use dependency injection,UserService uses UserRepository port implemented by DatabaseUserAdapter or MockUserAdapter,Mock all ports for unit tests test adapters separately integration tests at boundaries,Hexagonal,High
domain-driven-design,Modeling software based on business domain with ubiquitous language,Bounded contexts aggregates domain entities value objects domain services,Better business alignment reduced complexity improved communication,Requires domain expertise potential over-engineering for simple domains,Identify bounded contexts define aggregate roots create domain services avoid anemic models,E-commerce: Order aggregate with OrderItem entities OrderStatus value object OrderService,Unit test domain entities integration test domain services acceptance test business scenarios,Domain-Driven,High
clean-architecture,Dependency rule with business rules at center UI and infrastructure at edges,Entities UseCases Interface-Adapters Frameworks-Drivers in concentric circles,Independence testability separation of concerns framework agnosticism,Complexity for small applications many abstraction layers,Create use case classes dependency injection from outer layers define clear interfaces,RegisterUser use case depends on UserRepository interface implemented by database layer,Test use cases in isolation mock all dependencies integration tests at boundaries,Clean Architecture,High
component-composition,Building UIs through small composable components rather than large monoliths,Atomic design: atoms molecules organisms templates pages,Reusability consistency easier testing better maintenance,Component proliferation prop drilling without proper state management,Start with atoms build up to organisms use compound components for complex widgets,Button Input FormField SearchForm UserDashboard hierarchy with clear dependencies,Test atoms in isolation integration test organisms mock complex molecule dependencies,Component Architecture,Medium
event-driven-architecture,Components communicate through events rather than direct coupling,Event bus or pub-sub system with event handlers and event emitters,Loose coupling scalability easier feature addition,Debugging complexity event ordering issues potential memory leaks,Use custom event system or library define clear event schemas use TypeScript for event types,UserRegistered event triggers SendWelcomeEmail UpdateAnalytics CreateUserProfile handlers,Test event handlers in isolation integration test event flows end-to-end test scenarios,Feature-Based,High
layered-architecture,Horizontal organization with presentation business data access layers,UI Layer -> Service Layer -> Repository Layer -> Database Layer,Clear separation of concerns technology replacement easier team division,Tight coupling between layers performance overhead from layer traversal,Define clear interfaces between layers avoid bypassing layers use dependency injection,React components -> UserService -> UserRepository -> Database with clear abstractions,Unit test each layer mock adjacent layers integration test layer boundaries,Clean Architecture,Medium
micro-frontends,Decomposing frontend into smaller independent applications,Independent deployable frontend applications with shared design system,Team independence technology diversity independent deployment,Coordination overhead bundle duplication increased complexity,Use module federation or single-spa define clear boundaries share design system and utilities,User management checkout and inventory as separate applications with shared component library,Test each micro-frontend independently integration test application boundaries,Feature-Based,High
modular-monolith,Single deployable application with clear internal module boundaries,Well-defined modules with explicit interfaces and minimal coupling,Simplified deployment clear boundaries easier refactoring to microservices later,Requires discipline to maintain boundaries potential for tight coupling over time,Define module interfaces use dependency injection avoid cross-module data access,Authentication Order Payment modules with clear APIs and database boundaries within single application,Test modules in isolation integration test module interfaces contract test module boundaries,Domain-Driven,Medium
reactive-architecture,UI responds to state changes through reactive patterns and data flow,Unidirectional data flow with reactive streams observables or signals,Predictable state management easier debugging better performance optimizations,Learning curve complexity for simple interactions over-engineering risk,Use state management library implement reactive patterns avoid direct DOM manipulation,"Redux with actions/reducers MobX with observables Vue with reactivity Svelte with stores",Test state transitions unit test reducers/stores integration test component state interactions,Component Architecture,Medium
port-adapter-pattern,Isolate business logic using ports (interfaces) and adapters (implementations),Business logic core with port interfaces implemented by adapter classes,Technology independence easy mocking improved testability,Additional abstraction layer requires interface design discipline,Define port interfaces implement concrete adapters use dependency injection container,EmailService port with SMTPAdapter SendGridAdapter ConsoleAdapter implementations,Mock ports for unit tests test adapters separately verify port contracts,Hexagonal,Medium
aggregate-root-pattern,Domain entities that serve as consistency boundaries in complex domains,Root entity manages child entities enforces invariants controls access,Strong consistency clear ownership easier transaction management,Complexity for simple domains potential performance bottlenecks,Identify true aggregate boundaries implement invariant validation provide clear public interface,Order aggregate root manages OrderItems enforces business rules controls order state changes,Unit test aggregate invariants integration test aggregate persistence test domain events,Domain-Driven,High
cqrs-pattern,Command Query Responsibility Segregation separating reads from writes,Separate command models (writes) from query models (reads) with different optimization,Read/write optimization scalability different models for different use cases,Complexity increased infrastructure eventual consistency challenges,Separate command and query handlers use different data models implement event sourcing if needed,CreateOrder command handler and OrderQuery handler with optimized read models for different views,Test commands and queries separately integration test eventual consistency scenarios,Clean Architecture,High
event-sourcing,Store all changes as sequence of events rather than current state,Event store with event handlers for building read models and projections,Complete audit trail temporal queries easier debugging replay capability,Storage overhead complexity eventual consistency learning curve,Design events as facts use event store implement projection builders handle event versioning,UserRegistered UserEmailChanged UserDeactivated events build current user state from event stream,Test event handlers unit test projections integration test event store boundaries,Domain-Driven,High
repository-pattern,Encapsulate data access logic behind repository interfaces,Repository interface with implementations for different data sources,Data source independence easier testing clear data access boundaries,Additional abstraction layer potential over-engineering for simple CRUD,Define repository interfaces implement concrete repositories use dependency injection,UserRepository interface with DatabaseUserRepository and CacheUserRepository implementations,Mock repositories for unit tests test repository implementations separately,Clean Architecture,Medium
factory-pattern,Create objects without exposing creation logic using factory methods,Factory classes or functions that create and configure complex objects,Centralized creation logic easier testing configuration management,Additional complexity may be overkill for simple object creation,Create factory functions for complex objects use builder pattern for configuration,ComponentFactory creates configured components with proper props themes and event handlers,Unit test factory methods verify correct object creation test different factory configurations,Component Architecture,Low
observer-pattern,Define subscription mechanism to notify multiple objects about events,Observable objects with observer lists and notification methods,Loose coupling event-driven updates multiple subscribers,Potential memory leaks observer chain complexity debugging challenges,Implement observer interface maintain observer lists provide subscribe/unsubscribe methods,"StateManager notifies components when state changes EventBus notifies handlers when events occur",Test observer registration notification delivery memory cleanup,Component Architecture,Medium
strategy-pattern,Define family of algorithms make them interchangeable at runtime,Context class with strategy interface and concrete strategy implementations,Algorithm flexibility easy testing runtime strategy switching,Additional abstraction overhead potential over-engineering,Define strategy interface implement concrete strategies use dependency injection for strategy selection,ValidationStrategy with EmailValidation PasswordValidation PhoneValidation implementations,Unit test each strategy separately integration test strategy switching,Clean Architecture,Medium
decorator-pattern,Add behavior to objects dynamically without altering their structure,Wrapper components or HOCs that enhance base component functionality,Component enhancement composition over inheritance flexible feature addition,Wrapper complexity potential performance overhead debugging wrapped components,Create HOC or wrapper components maintain original interface use composition patterns,withLoading withAuth withAnalytics HOCs that enhance base components with additional behavior,Test decorators separately test enhanced components integration test decorator combinations,Component Architecture,Medium
facade-pattern,Provide simplified interface to complex subsystem hiding internal complexity,Facade class that coordinates multiple subsystem components,Simplified API reduced coupling easier client usage,Potential God object risk hiding too much complexity,Create facade for complex operations maintain single responsibility delegate to subsystems,APIFacade coordinates authentication data fetching caching and error handling subsystems,Unit test facade methods integration test subsystem coordination,Clean Architecture,Low
adapter-pattern,Allow incompatible interfaces to work together through adapter interface,Adapter class that translates between incompatible interfaces,Interface compatibility legacy system integration third-party library integration,Additional abstraction layer potential performance overhead,Create adapter for each incompatible interface maintain consistent internal interfaces,LegacyAPIAdapter translates modern interface calls to legacy API format for backward compatibility,Unit test adapter translation integration test with real incompatible systems,Hexagonal,Medium
singleton-pattern,Ensure single instance of class with global access point,Class with private constructor static instance method and instance storage,Global state management resource sharing single configuration source,Global state issues testing difficulties tight coupling potential concurrency issues,Use dependency injection instead of singleton implement lazy initialization consider alternatives,ConfigManager ensures single configuration instance but prefer dependency injection,Test singleton behavior verify single instance test cleanup in isolation,Component Architecture,Low
template-method-pattern,Define skeleton of algorithm in base class with customizable steps,Abstract base class with template method and abstract step methods,Code reuse algorithm consistency customizable behavior steps,Inheritance coupling rigid algorithm structure difficult testing,Create abstract base class define template method implement concrete subclasses,"FormValidator base class with validate() template method specific validators implement validation steps",Unit test template method test concrete implementations separately,Component Architecture,Medium
command-pattern,Encapsulate requests as objects allowing parameterization and queuing,Command objects with execute method and optional undo functionality,Request queuing undo/redo functionality macro commands logging,Additional object complexity over-engineering for simple operations,Create command interface implement concrete commands use command invoker for execution,UndoableCommand with execute() and undo() methods for text editor operations and form changes,Unit test command execution test undo functionality integration test command sequences,Clean Architecture,Medium